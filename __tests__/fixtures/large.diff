diff --git a/custom-endpoints/nightbot.mjs b/custom-endpoints/nightbot.mjs
index 31ed216e290f95bc1243ace7aec82590e7e4f61b..6236a84fbad6551a7a24fa44e6bca057ae58605d 100644
--- a/custom-endpoints/nightbot.mjs
+++ b/custom-endpoints/nightbot.mjs
@@ -1,6 +1,5 @@
 import { v4 as uuidv4 } from 'uuid';
 
-import cacheMachine from '../utils/cache-machine.mjs';
 import graphqlUtil from '../utils/graphql-util.mjs';
 
 const skipCache = false; //ENVIRONMENT !== 'production' || false;
@@ -9,31 +8,21 @@ function capitalize(s) {
     return s && s[0].toUpperCase() + s.slice(1);
 }
 
-export default async function (request, data, ctx) {
-    const requestStart = new Date();
+export default async function (request, data) {
+    if (request.method.toUpperCase() !== 'GET') {
+        return new Response(null, {
+            status: 405,
+            headers: { 'cache-control': 'public, max-age=2592000' },
+        });
+    }
     const requestId = uuidv4();
     const url = new URL(request.url);
 
     if (!url.searchParams.get('q')) {
-        return new Response(`Missing a query param called q`);
-    }
-
-    // Check the cache service for data first - If cached data exists, return it
-    if (!skipCache) {
-        const cachedResponse = await cacheMachine.get(env, 'nightbot', { q: url.searchParams.get('q') });
-        if (cachedResponse) {
-            // Construct a new response with the cached data
-            const newResponse = new Response(cachedResponse);
-            // Add a custom 'X-CACHE: HIT' header so we know the request hit the cache
-            newResponse.headers.append('X-CACHE', 'HIT');
-            console.log(`Request served from cache: ${new Date() - requestStart} ms`);
-            // Return the new cached response
-            return newResponse;
-        } else {
-            console.log('no cached response')
-        }
-    } else {
-        //console.log(`Skipping cache in ${ENVIRONMENT} environment`);
+        return new Response('Missing q param', {
+            status: 405,
+            headers: { 'cache-control': 'public, max-age=2592000' },
+        });
     }
 
     const context = {
@@ -72,26 +61,23 @@ export default async function (request, data, ctx) {
     };
     const items = await data.item.getItemsByName(context, url.searchParams.get('q'), info);
 
-    let response = 'Found no item matching that name';
+    let responseBody = 'Found no item matching that name';
 
     if (items.length > 0) {
         const bestPrice = items[0].sellFor.sort((a, b) => b.price - a.price);
         const itemName = data.item.getLocale(items[0].name, context, info);
-        response = `${itemName} ${new Intl.NumberFormat().format(bestPrice[0].price)} ₽ ${capitalize(bestPrice[0].source)} https://tarkov.dev/item/${items[0].normalizedName}`;
+        responseBody = `${itemName} ${new Intl.NumberFormat().format(bestPrice[0].price)} ₽ ${capitalize(bestPrice[0].source)} https://tarkov.dev/item/${items[0].normalizedName}`;
     }
 
-    let ttl = data.getRequestTtl(requestId);
-    if (ttl < 30) {
-        ttl = 30;
-    }
+    const ttl = data.getRequestTtl(requestId);
     delete data.requests[requestId];
 
     // Update the cache with the results of the query
     // don't update cache if result contained errors
-    if (!skipCache && ttl >= 30) {
-        // using waitUntil doens't hold up returning a response but keeps the worker alive as long as needed
-        ctx.waitUntil(cacheMachine.put(env, 'nightbot', {q: url.searchParams.get('q')}, response, String(ttl)));
+    const response = new Response(responseBody);
+    if (!skipCache && ttl > 0) {
+        response.headers.set('cache-ttl', String(ttl));
     }
 
-    return new Response(response);
+    return response;
 };
diff --git a/datasources/index.mjs b/datasources/index.mjs
index e2279b9c760e3ea25a36989c0f404ab557bfcb17..bcd42790c20c09ed616fa62f158ee59bae3dfe4b 100644
--- a/datasources/index.mjs
+++ b/datasources/index.mjs
@@ -164,6 +164,7 @@ class DataSource {
         if (ttl <= 0) {
             ttl = 0;
         }
+        ttl = Math.max(ttl, 60);
         return ttl;
     }
 }
diff --git a/index.mjs b/index.mjs
index 7223cef2a5ade15e1f30c6bf2c7752dc153020c2..db1869e5f37b81e453ba99d32605b753650e33b1 100644
--- a/index.mjs
+++ b/index.mjs
@@ -10,7 +10,6 @@ import typeDefs from './schema.mjs';
 import dynamicTypeDefs from './schema_dynamic.mjs';
 import resolvers from './resolvers/index.mjs';
 import graphqlUtil from './utils/graphql-util.mjs';
-import cacheMachine from './utils/cache-machine.mjs';
 
 import nightbot from './custom-endpoints/nightbot.mjs';
 import twitch from './custom-endpoints/twitch.mjs';
@@ -81,38 +80,38 @@ async function getSchema(data, context) {
     });
 }
 
-async function graphqlHandler(request, env, ctx, graphQLOptions) {
+async function graphqlHandler(request, env, requestBody) {
     const url = new URL(request.url);
     let query = false;
     let variables = false;
-    const requestStart = new Date();
 
     if (request.method === 'POST') {
         try {
-            const requestBody = await request.json();
+            if (!requestBody) {
+                requestBody = await request.json();              
+            }
+            if (typeof requestBody === 'string') {
+                requestBody = JSON.parse(requestBody);
+            }
             query = requestBody.query;
             variables = requestBody.variables;
         } catch (jsonError) {
             console.error(jsonError);
 
             return new Response(null, {
-                status: 503,
+                status: 400,
             });
         }
     } else if (request.method === 'GET') {
         query = url.searchParams.get('query');
         variables = url.searchParams.get('variables');
-    } else {
-        return new Response(null, {
-            status: 501,
-            headers: { 'cache-control': 'public, max-age=2592000' }
-        });
-    }
+    } 
+
     // Check for empty /graphql query
-    if (!query || query.trim() === "") {
+    if (!query || query.trim() === '') {
         return new Response('GraphQL requires a query in the body of the request',
             {
-                status: 200,
+                status: 400,
                 headers: { 'cache-control': 'public, max-age=2592000' }
             }
         );
@@ -134,27 +133,6 @@ async function graphqlHandler(request, env, ctx, graphQLOptions) {
         console.log('NewRelic health check');
         //return new Response(JSON.stringify({}), responseOptions);
     }
-    let specialCache = '';
-    const contentType = request.headers.get('content-type');
-    if (!contentType || !contentType.startsWith('application/json')) {
-        specialCache = 'application/json';
-    }
-
-    // Check the cache service for data first - If cached data exists, return it
-    if (!skipCache) {
-        const cachedResponse = await cacheMachine.get(env, query, variables, specialCache);
-        if (cachedResponse) {
-            // Construct a new response with the cached data
-            const newResponse = new Response(cachedResponse, responseOptions);
-            // Add a custom 'X-CACHE: HIT' header so we know the request hit the cache
-            newResponse.headers.append('X-CACHE', 'HIT');
-            console.log(`Request served from cache: ${new Date() - requestStart} ms`);
-            // Return the new cached response
-            return newResponse;
-        }
-    } else {
-        //console.log(`Skipping cache in ${ENVIRONMENT} environment`);
-    }
 
     const context = { data: dataAPI, util: graphqlUtil, requestId, lang: {}, warnings: [], errors: [] };
     let result = await graphql({schema: await getSchema(dataAPI, context), source: query, rootValue: {}, contextValue: context, variableValues: variables});
@@ -174,27 +152,18 @@ async function graphqlHandler(request, env, ctx, graphQLOptions) {
 
     let ttl = dataAPI.getRequestTtl(requestId);
 
-    if (specialCache === 'application/json') {
-        if (!result.warnings) {
-            result = Object.assign({warnings: []}, result);
-        }
-        ttl = 30 * 60;
-        result.warnings.push({message: `Your request does not have a "content-type" header set to "application/json". Requests missing this header are limited to resposnes that update every ${ttl/60} minutes.`});
-    }
-
     const body = JSON.stringify(result);
 
-    // Update the cache with the results of the query
+    const response = new Response(body, responseOptions)
+
     // don't update cache if result contained errors
-    if (!skipCache && (!result.errors || result.errors.length === 0) && ttl >= 30) {
-        // using waitUntil doens't hold up returning a response but keeps the worker alive as long as needed
-        ctx.waitUntil(cacheMachine.put(env, query, variables, body, String(ttl), specialCache));
+    if (!skipCache && (!result.errors || result.errors.length === 0) && ttl > 0) {
+        response.headers.set('cache-ttl', String(ttl));
     }
 
-    console.log(`Response time: ${new Date() - requestStart} ms`);
     //console.log(`${requestId} kvs loaded: ${dataAPI.requests[requestId].kvLoaded.join(', ')}`);
     delete dataAPI.requests[requestId];
-    return new Response(body, responseOptions);
+    return response;
 }
 
 const graphQLOptions = {
@@ -203,7 +172,7 @@ const graphQLOptions = {
 
     // Set the path for the GraphQL playground
     // This option can be removed to disable the playground route
-    playgroundEndpoint: '/___graphql',
+    playgroundEndpoint: '/',
 
     // When a request's path isn't matched, forward it to the origin
     forwardUnmatchedRequestsToOrigin: false,
@@ -219,63 +188,96 @@ const graphQLOptions = {
         allowCredentials: 'true',
         allowHeaders: 'Content-type',
         allowOrigin: '*',
-        allowMethods: 'GET, POST, PUT',
+        allowMethods: 'GET, POST',
     },
-
-    // Enable KV caching for external REST data source requests
-    // Note that you'll need to add a KV namespace called
-    // WORKERS_GRAPHQL_CACHE in your wrangler.toml file for this to
-    // work! See the project README for more information.
-    kvCache: false,
 };
 
+async function sha256(message) {
+    // encode as UTF-8
+    const msgBuffer = new TextEncoder().encode(message);
+    // hash the message
+    const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
+    // convert bytes to hex string
+    return [...new Uint8Array(hashBuffer)]
+      .map((b) => b.toString(16).padStart(2, '0'))
+      .join('');
+}
+
 export default {
 	async fetch(request, env, ctx) {
+        if (!['GET', 'POST'].includes(request.method.toUpperCase())) {
+            return new Response(null, {
+                status: 405,
+                headers: { 'cache-control': 'public, max-age=2592000' },
+            });
+        }
+        const requestStart = new Date();
 		const url = new URL(request.url);
 
+        const cacheUrl = new URL(request.url);
+        let cacheKey = new Request(cacheUrl.toString().toLowerCase(), request);
+        const requestBody = await request.text();
+        if (request.method.toUpperCase() === 'POST') {
+            cacheUrl.pathname = '/posts' + cacheUrl.pathname + await sha256(requestBody);
+            cacheKey = new Request(cacheUrl.toString().toLowerCase(), {
+                headers: request.headers,
+                method: 'GET',
+            });
+        }
+        const cache = env.ENVIRONMENT === 'production' ? caches.default : await caches.open('dev:cache');
+        let response = await cache.match(cacheKey);
+        if (!skipCache && response) {
+            return response;
+        }
+
         try {
             if (url.pathname === '/twitch') {
-                const response = request.method === 'OPTIONS' ? new Response('', { status: 204 }) : await twitch(env);
+                response = await twitch(env);
                 if (graphQLOptions.cors) {
                     setCors(response, graphQLOptions.cors);
                 }
+            }
 
-                return response;
+            if (url.pathname === graphQLOptions.playgroundEndpoint) {
+                return playground(request, graphQLOptions);
+            }
+
+            if (graphQLOptions.forwardUnmatchedRequestsToOrigin) {
+                return fetch(request);
             }
 
             if (!dataAPI) {
                 dataAPI = new DataSource(env);
             }
             
-            if (url.pathname === '/webhook/nightbot') {
-                return nightbot(request, dataAPI, env, ctx);
-            }
-
-            if (url.pathname === '/webhook/stream-elements') {
-                return nightbot(request, dataAPI, env, ctx);
-            }
-
-            if (url.pathname === '/webhook/moobot') {
-                return nightbot(request, dataAPI, env, ctx);
+            if (url.pathname === '/webhook/nightbot' ||
+                url.pathname === '/webhook/stream-elements' ||
+                url.pathname === '/webhook/moobot'
+            ) {
+                response = await nightbot(request, dataAPI);
             }
 
             if (url.pathname === graphQLOptions.baseEndpoint) {
-                const response = request.method === 'OPTIONS' ? new Response('', { status: 204 }) : await graphqlHandler(request, env, ctx, graphQLOptions);
+                response = await graphqlHandler(request, env, requestBody);
                 if (graphQLOptions.cors) {
                     setCors(response, graphQLOptions.cors);
                 }
-
-                return response;
             }
 
-            if (graphQLOptions.playgroundEndpoint && url.pathname === graphQLOptions.playgroundEndpoint) {
-                return playground(request, graphQLOptions);
+            if (!response) {
+                response = new Response('Not found', { status: 404 });
             }
-
-            if (graphQLOptions.forwardUnmatchedRequestsToOrigin) {
-                return fetch(request);
+            if (!skipCache && response.headers.has('cache-ttl')) {
+                const ttl = parseInt(response.headers.get('cache-ttl'));
+                response.headers.delete('cache-ttl');
+                if (ttl > 0) {
+                    response.headers.set('Cache-Control', `s-maxage=${ttl}`);
+                    //response.headers.delete('cache-ttl');
+                    ctx.waitUntil(cache.put(cacheKey, response.clone()));
+                }
             }
-            return new Response('Not found', { status: 404 });
+            console.log(`Response time: ${new Date() - requestStart} ms`);
+			return response;
         } catch (err) {
             return new Response(graphQLOptions.debug ? err : 'Something went wrong', { status: 500 });
         }
diff --git a/kv-cache.js b/kv-cache.js
deleted file mode 100644
index d377b0b0979307444d45bb9bb6dd3bd9539f3ae7..0000000000000000000000000000000000000000
--- a/kv-cache.js
+++ /dev/null
@@ -1,16 +0,0 @@
-class KVCache {
-    get(key) {
-        return WORKERS_GRAPHQL_CACHE.get(key)
-    }
-
-    set(key, value, options) {
-        const opts = {}
-        const ttl = options && options.ttl
-        if (ttl) {
-            opts.expirationTtl = ttl
-        }
-        return WORKERS_GRAPHQL_CACHE.put(key, value, opts)
-    }
-};
-
-module.exports = KVCache;
diff --git a/utils/cache-machine.mjs b/utils/cache-machine.mjs
deleted file mode 100644
index f322b64ebc58a3e253c31f0d64194bfe23655a7d..0000000000000000000000000000000000000000
--- a/utils/cache-machine.mjs
+++ /dev/null
@@ -1,138 +0,0 @@
-// cache url
-const cacheUrl = 'https://cache.tarkov.dev'
-
-let cacheFailCount = 0;
-let cachePaused = false;
-
-function pauseCache() {
-    cacheFailCount++;
-    if (cacheFailCount <= 2) {
-        return;
-    }
-    cachePaused = true;
-    setTimeout(() => {
-        cachePaused = false;
-        cacheFailCount = 0;
-    }, 60000);
-}
-
-async function fetchWithTimeout(resource, options = {}) {
-    const { timeout = 1000 } = options;
-    return fetch(resource, {
-        ...options,
-        signal: AbortSignal.timeout(timeout),
-    });
-}
-
-// Helper function to create a hash from a string
-// :param string: string to hash
-// :return: SHA-256 hash of string
-async function hash(string) {
-    const utf8 = new TextEncoder().encode(string);
-    const hashBuffer = await crypto.subtle.digest('SHA-256', utf8);
-    const hashArray = Array.from(new Uint8Array(hashBuffer));
-    const hashHex = hashArray
-        .map((bytes) => bytes.toString(16).padStart(2, '0'))
-        .join('');
-
-    return hashHex;
-}
-
-// Updates the cache with the results of a query
-// :param json: the incoming request in json
-// :param body: the body to cache
-// :return: true if successful, false if not
-async function updateCache(env, query, variables, body, ttl = '', specialCache = '') {
-    try {
-        if (!env.CACHE_BASIC_AUTH) {
-            console.warn('env.CACHE_BASIC_AUTH is not set; skipping cache check');
-            return false;
-        }
-        if (cachePaused) {
-            console.warn('Cache paused; skipping cache update');
-            return false;
-        }
-        // Get the cacheKey from the request
-        query = query.trim();
-        console.log(`caching response for ${env.ENVIRONMENT} environment`);
-        const cacheKey = await hash(env.ENVIRONMENT + query + JSON.stringify(variables) + specialCache);
-
-        // headers and POST body
-        const headersPost = {
-            body: JSON.stringify({ key: cacheKey, value: body, ttl }),
-            method: 'POST',
-            headers: {
-                'content-type': 'application/json;charset=UTF-8',
-                'Authorization': `Basic ${env.CACHE_BASIC_AUTH}`
-            },
-            timeout: 10000,
-        };
-
-        // Update the cache
-        const response = await fetchWithTimeout(`${cacheUrl}/api/cache`, headersPost);
-
-        // Log non-200 responses
-        if (response.status !== 200) {
-            console.error(`failed to write to cache: ${response.status}`);
-            return false
-        }
-        cacheFailCount = 0;
-        return true
-    } catch (error) {
-        if (error.message === 'The operation was aborted due to timeout') {
-            console.warn('Updating cache timed out');
-            pauseCache();
-            return false;
-        }
-        console.error('updateCache error: ' + error.message);
-        return false;
-    }
-}
-
-// Checks the caching service to see if a request has been cached
-// :param json: the json payload of the incoming worker request
-// :return: json results of the item found in the cache or false if not found
-async function checkCache(env, query, variables, specialCache = '') {
-    try {
-        if (!env.CACHE_BASIC_AUTH) {
-            console.warn('env.CACHE_BASIC_AUTH is not set; skipping cache check');
-            return false;
-        }
-        if (cachePaused) {
-            console.warn('Cache paused; skipping cache check');
-            return false;
-        }
-        query = query.trim();
-        const cacheKey = await hash(env.ENVIRONMENT + query + JSON.stringify(variables) + specialCache);
-        if (!cacheKey) {
-            console.warn('Skipping cache check; key is empty');
-            return false;
-        }
-
-        const response = await fetchWithTimeout(`${cacheUrl}/api/cache?key=${cacheKey}`, { 
-            headers: {
-                'content-type': 'application/json;charset=UTF-8',
-                'Authorization': `Basic ${env.CACHE_BASIC_AUTH}`
-            }, 
-        });
-        cacheFailCount = 0;
-        if (response.status === 200) {
-            return await response.json();
-        }
-
-        return false
-    } catch (error) {
-        if (error.message === 'The operation was aborted due to timeout') {
-            console.warn('Checking cache timed out');
-            pauseCache();
-            return false;
-        }
-        console.error('checkCache error: ' + error.message);
-        return false;
-    }
-}
-
-export default {
-    get: checkCache,
-    put: updateCache
-};
diff --git a/custom-endpoints/nightbot.mjs b/custom-endpoints/nightbot.mjs
index 31ed216e290f95bc1243ace7aec82590e7e4f61b..6236a84fbad6551a7a24fa44e6bca057ae58605d 100644
--- a/custom-endpoints/nightbot.mjs
+++ b/custom-endpoints/nightbot.mjs
@@ -1,6 +1,5 @@
 import { v4 as uuidv4 } from 'uuid';
 
-import cacheMachine from '../utils/cache-machine.mjs';
 import graphqlUtil from '../utils/graphql-util.mjs';
 
 const skipCache = false; //ENVIRONMENT !== 'production' || false;
@@ -9,31 +8,21 @@ function capitalize(s) {
     return s && s[0].toUpperCase() + s.slice(1);
 }
 
-export default async function (request, data, ctx) {
-    const requestStart = new Date();
+export default async function (request, data) {
+    if (request.method.toUpperCase() !== 'GET') {
+        return new Response(null, {
+            status: 405,
+            headers: { 'cache-control': 'public, max-age=2592000' },
+        });
+    }
     const requestId = uuidv4();
     const url = new URL(request.url);
 
     if (!url.searchParams.get('q')) {
-        return new Response(`Missing a query param called q`);
-    }
-
-    // Check the cache service for data first - If cached data exists, return it
-    if (!skipCache) {
-        const cachedResponse = await cacheMachine.get(env, 'nightbot', { q: url.searchParams.get('q') });
-        if (cachedResponse) {
-            // Construct a new response with the cached data
-            const newResponse = new Response(cachedResponse);
-            // Add a custom 'X-CACHE: HIT' header so we know the request hit the cache
-            newResponse.headers.append('X-CACHE', 'HIT');
-            console.log(`Request served from cache: ${new Date() - requestStart} ms`);
-            // Return the new cached response
-            return newResponse;
-        } else {
-            console.log('no cached response')
-        }
-    } else {
-        //console.log(`Skipping cache in ${ENVIRONMENT} environment`);
+        return new Response('Missing q param', {
+            status: 405,
+            headers: { 'cache-control': 'public, max-age=2592000' },
+        });
     }
 
     const context = {
@@ -72,26 +61,23 @@ export default async function (request, data, ctx) {
     };
     const items = await data.item.getItemsByName(context, url.searchParams.get('q'), info);
 
-    let response = 'Found no item matching that name';
+    let responseBody = 'Found no item matching that name';
 
     if (items.length > 0) {
         const bestPrice = items[0].sellFor.sort((a, b) => b.price - a.price);
         const itemName = data.item.getLocale(items[0].name, context, info);
-        response = `${itemName} ${new Intl.NumberFormat().format(bestPrice[0].price)} ₽ ${capitalize(bestPrice[0].source)} https://tarkov.dev/item/${items[0].normalizedName}`;
+        responseBody = `${itemName} ${new Intl.NumberFormat().format(bestPrice[0].price)} ₽ ${capitalize(bestPrice[0].source)} https://tarkov.dev/item/${items[0].normalizedName}`;
     }
 
-    let ttl = data.getRequestTtl(requestId);
-    if (ttl < 30) {
-        ttl = 30;
-    }
+    const ttl = data.getRequestTtl(requestId);
     delete data.requests[requestId];
 
     // Update the cache with the results of the query
     // don't update cache if result contained errors
-    if (!skipCache && ttl >= 30) {
-        // using waitUntil doens't hold up returning a response but keeps the worker alive as long as needed
-        ctx.waitUntil(cacheMachine.put(env, 'nightbot', {q: url.searchParams.get('q')}, response, String(ttl)));
+    const response = new Response(responseBody);
+    if (!skipCache && ttl > 0) {
+        response.headers.set('cache-ttl', String(ttl));
     }
 
-    return new Response(response);
+    return response;
 };
diff --git a/datasources/index.mjs b/datasources/index.mjs
index e2279b9c760e3ea25a36989c0f404ab557bfcb17..bcd42790c20c09ed616fa62f158ee59bae3dfe4b 100644
--- a/datasources/index.mjs
+++ b/datasources/index.mjs
@@ -164,6 +164,7 @@ class DataSource {
         if (ttl <= 0) {
             ttl = 0;
         }
+        ttl = Math.max(ttl, 60);
         return ttl;
     }
 }
diff --git a/index.mjs b/index.mjs
index 7223cef2a5ade15e1f30c6bf2c7752dc153020c2..db1869e5f37b81e453ba99d32605b753650e33b1 100644
--- a/index.mjs
+++ b/index.mjs
@@ -10,7 +10,6 @@ import typeDefs from './schema.mjs';
 import dynamicTypeDefs from './schema_dynamic.mjs';
 import resolvers from './resolvers/index.mjs';
 import graphqlUtil from './utils/graphql-util.mjs';
-import cacheMachine from './utils/cache-machine.mjs';
 
 import nightbot from './custom-endpoints/nightbot.mjs';
 import twitch from './custom-endpoints/twitch.mjs';
@@ -81,38 +80,38 @@ async function getSchema(data, context) {
     });
 }
 
-async function graphqlHandler(request, env, ctx, graphQLOptions) {
+async function graphqlHandler(request, env, requestBody) {
     const url = new URL(request.url);
     let query = false;
     let variables = false;
-    const requestStart = new Date();
 
     if (request.method === 'POST') {
         try {
-            const requestBody = await request.json();
+            if (!requestBody) {
+                requestBody = await request.json();              
+            }
+            if (typeof requestBody === 'string') {
+                requestBody = JSON.parse(requestBody);
+            }
             query = requestBody.query;
             variables = requestBody.variables;
         } catch (jsonError) {
             console.error(jsonError);
 
             return new Response(null, {
-                status: 503,
+                status: 400,
             });
         }
     } else if (request.method === 'GET') {
         query = url.searchParams.get('query');
         variables = url.searchParams.get('variables');
-    } else {
-        return new Response(null, {
-            status: 501,
-            headers: { 'cache-control': 'public, max-age=2592000' }
-        });
-    }
+    } 
+
     // Check for empty /graphql query
-    if (!query || query.trim() === "") {
+    if (!query || query.trim() === '') {
         return new Response('GraphQL requires a query in the body of the request',
             {
-                status: 200,
+                status: 400,
                 headers: { 'cache-control': 'public, max-age=2592000' }
             }
         );
@@ -134,27 +133,6 @@ async function graphqlHandler(request, env, ctx, graphQLOptions) {
         console.log('NewRelic health check');
         //return new Response(JSON.stringify({}), responseOptions);
     }
-    let specialCache = '';
-    const contentType = request.headers.get('content-type');
-    if (!contentType || !contentType.startsWith('application/json')) {
-        specialCache = 'application/json';
-    }
-
-    // Check the cache service for data first - If cached data exists, return it
-    if (!skipCache) {
-        const cachedResponse = await cacheMachine.get(env, query, variables, specialCache);
-        if (cachedResponse) {
-            // Construct a new response with the cached data
-            const newResponse = new Response(cachedResponse, responseOptions);
-            // Add a custom 'X-CACHE: HIT' header so we know the request hit the cache
-            newResponse.headers.append('X-CACHE', 'HIT');
-            console.log(`Request served from cache: ${new Date() - requestStart} ms`);
-            // Return the new cached response
-            return newResponse;
-        }
-    } else {
-        //console.log(`Skipping cache in ${ENVIRONMENT} environment`);
-    }
 
     const context = { data: dataAPI, util: graphqlUtil, requestId, lang: {}, warnings: [], errors: [] };
     let result = await graphql({schema: await getSchema(dataAPI, context), source: query, rootValue: {}, contextValue: context, variableValues: variables});
@@ -174,27 +152,18 @@ async function graphqlHandler(request, env, ctx, graphQLOptions) {
 
     let ttl = dataAPI.getRequestTtl(requestId);
 
-    if (specialCache === 'application/json') {
-        if (!result.warnings) {
-            result = Object.assign({warnings: []}, result);
-        }
-        ttl = 30 * 60;
-        result.warnings.push({message: `Your request does not have a "content-type" header set to "application/json". Requests missing this header are limited to resposnes that update every ${ttl/60} minutes.`});
-    }
-
     const body = JSON.stringify(result);
 
-    // Update the cache with the results of the query
+    const response = new Response(body, responseOptions)
+
     // don't update cache if result contained errors
-    if (!skipCache && (!result.errors || result.errors.length === 0) && ttl >= 30) {
-        // using waitUntil doens't hold up returning a response but keeps the worker alive as long as needed
-        ctx.waitUntil(cacheMachine.put(env, query, variables, body, String(ttl), specialCache));
+    if (!skipCache && (!result.errors || result.errors.length === 0) && ttl > 0) {
+        response.headers.set('cache-ttl', String(ttl));
     }
 
-    console.log(`Response time: ${new Date() - requestStart} ms`);
     //console.log(`${requestId} kvs loaded: ${dataAPI.requests[requestId].kvLoaded.join(', ')}`);
     delete dataAPI.requests[requestId];
-    return new Response(body, responseOptions);
+    return response;
 }
 
 const graphQLOptions = {
@@ -203,7 +172,7 @@ const graphQLOptions = {
 
     // Set the path for the GraphQL playground
     // This option can be removed to disable the playground route
-    playgroundEndpoint: '/___graphql',
+    playgroundEndpoint: '/',
 
     // When a request's path isn't matched, forward it to the origin
     forwardUnmatchedRequestsToOrigin: false,
@@ -219,63 +188,96 @@ const graphQLOptions = {
         allowCredentials: 'true',
         allowHeaders: 'Content-type',
         allowOrigin: '*',
-        allowMethods: 'GET, POST, PUT',
+        allowMethods: 'GET, POST',
     },
-
-    // Enable KV caching for external REST data source requests
-    // Note that you'll need to add a KV namespace called
-    // WORKERS_GRAPHQL_CACHE in your wrangler.toml file for this to
-    // work! See the project README for more information.
-    kvCache: false,
 };
 
+async function sha256(message) {
+    // encode as UTF-8
+    const msgBuffer = new TextEncoder().encode(message);
+    // hash the message
+    const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
+    // convert bytes to hex string
+    return [...new Uint8Array(hashBuffer)]
+      .map((b) => b.toString(16).padStart(2, '0'))
+      .join('');
+}
+
 export default {
 	async fetch(request, env, ctx) {
+        if (!['GET', 'POST'].includes(request.method.toUpperCase())) {
+            return new Response(null, {
+                status: 405,
+                headers: { 'cache-control': 'public, max-age=2592000' },
+            });
+        }
+        const requestStart = new Date();
 		const url = new URL(request.url);
 
+        const cacheUrl = new URL(request.url);
+        let cacheKey = new Request(cacheUrl.toString().toLowerCase(), request);
+        const requestBody = await request.text();
+        if (request.method.toUpperCase() === 'POST') {
+            cacheUrl.pathname = '/posts' + cacheUrl.pathname + await sha256(requestBody);
+            cacheKey = new Request(cacheUrl.toString().toLowerCase(), {
+                headers: request.headers,
+                method: 'GET',
+            });
+        }
+        const cache = env.ENVIRONMENT === 'production' ? caches.default : await caches.open('dev:cache');
+        let response = await cache.match(cacheKey);
+        if (!skipCache && response) {
+            return response;
+        }
+
         try {
             if (url.pathname === '/twitch') {
-                const response = request.method === 'OPTIONS' ? new Response('', { status: 204 }) : await twitch(env);
+                response = await twitch(env);
                 if (graphQLOptions.cors) {
                     setCors(response, graphQLOptions.cors);
                 }
+            }
 
-                return response;
+            if (url.pathname === graphQLOptions.playgroundEndpoint) {
+                return playground(request, graphQLOptions);
+            }
+
+            if (graphQLOptions.forwardUnmatchedRequestsToOrigin) {
+                return fetch(request);
             }
 
             if (!dataAPI) {
                 dataAPI = new DataSource(env);
             }
             
-            if (url.pathname === '/webhook/nightbot') {
-                return nightbot(request, dataAPI, env, ctx);
-            }
-
-            if (url.pathname === '/webhook/stream-elements') {
-                return nightbot(request, dataAPI, env, ctx);
-            }
-
-            if (url.pathname === '/webhook/moobot') {
-                return nightbot(request, dataAPI, env, ctx);
+            if (url.pathname === '/webhook/nightbot' ||
+                url.pathname === '/webhook/stream-elements' ||
+                url.pathname === '/webhook/moobot'
+            ) {
+                response = await nightbot(request, dataAPI);
             }
 
             if (url.pathname === graphQLOptions.baseEndpoint) {
-                const response = request.method === 'OPTIONS' ? new Response('', { status: 204 }) : await graphqlHandler(request, env, ctx, graphQLOptions);
+                response = await graphqlHandler(request, env, requestBody);
                 if (graphQLOptions.cors) {
                     setCors(response, graphQLOptions.cors);
                 }
-
-                return response;
             }
 
-            if (graphQLOptions.playgroundEndpoint && url.pathname === graphQLOptions.playgroundEndpoint) {
-                return playground(request, graphQLOptions);
+            if (!response) {
+                response = new Response('Not found', { status: 404 });
             }
-
-            if (graphQLOptions.forwardUnmatchedRequestsToOrigin) {
-                return fetch(request);
+            if (!skipCache && response.headers.has('cache-ttl')) {
+                const ttl = parseInt(response.headers.get('cache-ttl'));
+                response.headers.delete('cache-ttl');
+                if (ttl > 0) {
+                    response.headers.set('Cache-Control', `s-maxage=${ttl}`);
+                    //response.headers.delete('cache-ttl');
+                    ctx.waitUntil(cache.put(cacheKey, response.clone()));
+                }
             }
-            return new Response('Not found', { status: 404 });
+            console.log(`Response time: ${new Date() - requestStart} ms`);
+			return response;
         } catch (err) {
             return new Response(graphQLOptions.debug ? err : 'Something went wrong', { status: 500 });
         }
diff --git a/kv-cache.js b/kv-cache.js
deleted file mode 100644
index d377b0b0979307444d45bb9bb6dd3bd9539f3ae7..0000000000000000000000000000000000000000
--- a/kv-cache.js
+++ /dev/null
@@ -1,16 +0,0 @@
-class KVCache {
-    get(key) {
-        return WORKERS_GRAPHQL_CACHE.get(key)
-    }
-
-    set(key, value, options) {
-        const opts = {}
-        const ttl = options && options.ttl
-        if (ttl) {
-            opts.expirationTtl = ttl
-        }
-        return WORKERS_GRAPHQL_CACHE.put(key, value, opts)
-    }
-};
-
-module.exports = KVCache;
diff --git a/dist/index.js b/dist/index.js
index f958af88a86331b6ef225563a9d1433c200f5d69..562330dd38b9daaeb9bec6daa5d30823337317f8 100644
Binary files a/dist/index.js and b/dist/index.js differ
diff --git a/dist/index.js.map b/dist/index.js.map
index ae7ee61052d85e707cfbe80c6c3e4b2efdc09f65..0b2fd2b0d2039d0fb18cecf2e771cf664e03d796 100644
Binary files a/dist/index.js.map and b/dist/index.js.map differ
diff --git a/utils/cache-machine.mjs b/utils/cache-machine.mjs
deleted file mode 100644
index f322b64ebc58a3e253c31f0d64194bfe23655a7d..0000000000000000000000000000000000000000
--- a/utils/cache-machine.mjs
+++ /dev/null
@@ -1,138 +0,0 @@
-// cache url
-const cacheUrl = 'https://cache.tarkov.dev'
-
-let cacheFailCount = 0;
-let cachePaused = false;
-
-function pauseCache() {
-    cacheFailCount++;
-    if (cacheFailCount <= 2) {
-        return;
-    }
-    cachePaused = true;
-    setTimeout(() => {
-        cachePaused = false;
-        cacheFailCount = 0;
-    }, 60000);
-}
-
-async function fetchWithTimeout(resource, options = {}) {
-    const { timeout = 1000 } = options;
-    return fetch(resource, {
-        ...options,
-        signal: AbortSignal.timeout(timeout),
-    });
-}
-
-// Helper function to create a hash from a string
-// :param string: string to hash
-// :return: SHA-256 hash of string
-async function hash(string) {
-    const utf8 = new TextEncoder().encode(string);
-    const hashBuffer = await crypto.subtle.digest('SHA-256', utf8);
-    const hashArray = Array.from(new Uint8Array(hashBuffer));
-    const hashHex = hashArray
-        .map((bytes) => bytes.toString(16).padStart(2, '0'))
-        .join('');
-
-    return hashHex;
-}
-
-// Updates the cache with the results of a query
-// :param json: the incoming request in json
-// :param body: the body to cache
-// :return: true if successful, false if not
-async function updateCache(env, query, variables, body, ttl = '', specialCache = '') {
-    try {
-        if (!env.CACHE_BASIC_AUTH) {
-            console.warn('env.CACHE_BASIC_AUTH is not set; skipping cache check');
-            return false;
-        }
-        if (cachePaused) {
-            console.warn('Cache paused; skipping cache update');
-            return false;
-        }
-        // Get the cacheKey from the request
-        query = query.trim();
-        console.log(`caching response for ${env.ENVIRONMENT} environment`);
-        const cacheKey = await hash(env.ENVIRONMENT + query + JSON.stringify(variables) + specialCache);
-
-        // headers and POST body
-        const headersPost = {
-            body: JSON.stringify({ key: cacheKey, value: body, ttl }),
-            method: 'POST',
-            headers: {
-                'content-type': 'application/json;charset=UTF-8',
-                'Authorization': `Basic ${env.CACHE_BASIC_AUTH}`
-            },
-            timeout: 10000,
-        };
-
-        // Update the cache
-        const response = await fetchWithTimeout(`${cacheUrl}/api/cache`, headersPost);
-
-        // Log non-200 responses
-        if (response.status !== 200) {
-            console.error(`failed to write to cache: ${response.status}`);
-            return false
-        }
-        cacheFailCount = 0;
-        return true
-    } catch (error) {
-        if (error.message === 'The operation was aborted due to timeout') {
-            console.warn('Updating cache timed out');
-            pauseCache();
-            return false;
-        }
-        console.error('updateCache error: ' + error.message);
-        return false;
-    }
-}
-
-// Checks the caching service to see if a request has been cached
-// :param json: the json payload of the incoming worker request
-// :return: json results of the item found in the cache or false if not found
-async function checkCache(env, query, variables, specialCache = '') {
-    try {
-        if (!env.CACHE_BASIC_AUTH) {
-            console.warn('env.CACHE_BASIC_AUTH is not set; skipping cache check');
-            return false;
-        }
-        if (cachePaused) {
-            console.warn('Cache paused; skipping cache check');
-            return false;
-        }
-        query = query.trim();
-        const cacheKey = await hash(env.ENVIRONMENT + query + JSON.stringify(variables) + specialCache);
-        if (!cacheKey) {
-            console.warn('Skipping cache check; key is empty');
-            return false;
-        }
-
-        const response = await fetchWithTimeout(`${cacheUrl}/api/cache?key=${cacheKey}`, { 
-            headers: {
-                'content-type': 'application/json;charset=UTF-8',
-                'Authorization': `Basic ${env.CACHE_BASIC_AUTH}`
-            }, 
-        });
-        cacheFailCount = 0;
-        if (response.status === 200) {
-            return await response.json();
-        }
-
-        return false
-    } catch (error) {
-        if (error.message === 'The operation was aborted due to timeout') {
-            console.warn('Checking cache timed out');
-            pauseCache();
-            return false;
-        }
-        console.error('checkCache error: ' + error.message);
-        return false;
-    }
-}
-
-export default {
-    get: checkCache,
-    put: updateCache
-};
